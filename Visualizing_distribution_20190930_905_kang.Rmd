---
output: html_notebook
---

## Chapter 9 Visualizing data distributions

In this Chapter, we first discuss properties of a variety of distributions and how to visualize distributions using a motivating example of student heights. We then discuss the **ggplot2** geometries for these visualizations in Section 9.16.

### 9.1 Variable types

We will be working with two types of variables: categorical and numeric. Each can be divided into two other groups: categorical can be ordinal or not, whereas numerical variables can be discrete or continuous.

When each entry in a vector comes from one of a small number of groups, we refer to the data as _categorical data_. Two simple examples are sex (male or female) and regions (Northeast, South, North Central, West).

> Categorical variables contain a finite number of categories or distinct groups. Categorical data might not have a logical order.  
> categorical predictors : gender, material type, payment method

Example of numerical data are population sizes, murder rates, and heights. Some numerical data can be treated as ordered categorical. We can further divide numerical data into continuous and discrete.

Continuous variables are those that can take any value, such as heights, if measured with enough precision. For example, a pair of twins may be 68.12 and 68.11 inches respectively. Counts, such as population sizes, are discrete because they have to be round numbers.

> Continuous variables are numeric variables that have an infinite number of values between any two values. A continuous variable can be numeric or date/time.  
> the length of a part, the date and time a payment

> Discrete variables are numeric variables that have a countable number of values between any two values. A discrete variable is always numeric.  
> the number of customer complaints, the number of flaws or defects

### 9.2 Case study: describing student heights

```{r}
library(tidyverse)
library(dslabs)
data(heights)
head(heights)
```

### 9.3 Distribution function

In some cases, the average and the standard deviation are pretty much all we need to understand the data.

The most basic statistical summary of a list of objects or numbers is its distribution. The simplest way to think of a distribution is as a compact description of a list with many entries.For example, with categorical data, the distribution simply describes the proportion of each unique category. The sex represented in the heights dataset is:

```{}
#>
#> Female   Male
#>  0.227  0.773
```

When there are more categories, then a simple barplot describes the distribution.

### 9.4 Cumulative distribution functions

Numerical data that are not categorical also have distributions. In general, when data is not categorical, reporting the frequency of each entry is not an effective summary since most entries are unique.

A more useful way to define a distribution for numeric data is to define a function that reports the proportion of the data below $a$ for all possible values of $a$. This function is called the cumulative distribution function (CDF).

<center>$F(a) = Pr(x \le a)$</center>

A plot of $F$ for the male height data:

![](https://rafalab.github.io/dsbook/book_files/figure-html/ecdf-1.png)

Similar to what the frequency table does for categorical data, the CDF defines the distribution for numerical data. From the plot, we can see that 16% of the values are below 65, since $F(66) = 0.164$, or that 84% of the values are below 72, $F(72) = 0.841$, etc... In fact, we can report the proportion of values between any two heights, say $a$ and $b$, by computing $F(b) - F(a)$.

### 9.5 Histograms

The simplest way to make a histogram is to divide the span of our data into non-overlapping bins of the same size. Then, for each bin, we count the number of values that fall in that interval. The histogram plots these counts as bars with the base of the bar defined by the intervals.

The histogram for the height data splitting the range of values into one inch intervals:
$[49.5, 50.5], [51.5, 52.5], [53.5, 54.5],..., [82.5, 83.5]$

![](https://rafalab.github.io/dsbook/book_files/figure-html/height-histogram-1.png)

A histogram is similar to a barplot, but it differs in that the x-axis is numerical, not categorical.

Immediately learn some important properties about our data.

> First, the range of the data is from 50 to 84 with the majority (more than 95%) between 63 and 75 inches. 
> Second, the heights are close to symmetric around 69 inches.  
> Also, by adding up counts, ET could obtain a very good approximation of the proportion of the data in any interval.

Therefore, the histogram above is not only easy to interpret, but also provides almost all the information contained in the raw list of 812 heights with about 30 bin counts.

### 9.6 Smoothed density

Smooth density plots are aesthetically more appealing than histograms.

What a smooth density plot looks like for our heights data:

![](https://rafalab.github.io/dsbook/book_files/figure-html/example-of-smoothed-density-1.png)

we no longer have sharp edges at the interval boundaries and many of the local peaks have been removed. Also, the scale of the y-axis changed from counts to _density_.

To understand the smooth densities, we have to understand _estimates_.

The assumption is that if we show this, the height of consecutive bins will be similar. This is what we mean by smooth: we don’t have big jumps in the heights of consecutive bins.

> bin width가 줄어들수록 histogram은 smoother해진다

The smooth density is basically the curve that goes through the top of the histogram bars when the bins are very, very small.  
To make the curve not depend on the hypothetical size of the hypothetical list, we compute the curve on frequencies rather than counts.

Now, back to reality. We don’t have millions of measurements. Instead, we have 812 and we can’t make a histogram with very small bins.

We therefore make a histogram, using bin sizes appropriate for our data and computing frequencies rather than counts, and we draw a smooth curve that goes through the tops of the histogram bars. The following plots demonstrate the steps that lead to a smooth density:

![](https://rafalab.github.io/dsbook/book_files/figure-html/smooth-density-2-1.png)

However, remember that _smooth_ is a relative term. We can actually control the smoothness of the curve that defines the smooth density through an option in the function that computes the smooth density curve. Here are two examples using different degrees of smoothness on the same histogram:

![](https://rafalab.github.io/dsbook/book_files/figure-html/densities-different-smoothness-1.png)

We need to make this choice with care as the resulting visualizations can change our interpretation of the data. We should select a degree of smoothness that we can defend as being representative of the underlying data.

While the histogram is an assumption-free summary, the smoothed density is based on some assumptions.

#### 9.6.1 Interpreting the y-axis

Interpreting the y-axis of a smooth density plot is not straightforward. It is scaled so that the area under the density curve adds up to 1. For other size intervals, the best way to determine the proportion of data in that interval is by computing the proportion of the total area contained in that interval.

The proportion of values between 65 and 68:

![](https://rafalab.github.io/dsbook/book_files/figure-html/area-under-curve-1.png)

The proportion of this area is about 0.3, meaning that about that proportion is between 65 and 68 inches.

#### 9.6.2 Densities permit stratification

An advantage of smooth densities over histograms for visualization purposes is that **densities makes it easier to compare two distributions**. This is in large part because the jagged edges of the histogram add clutter.

Comparing male and female heights:

![](https://rafalab.github.io/dsbook/book_files/figure-html/two-densities-one-plot-1.png)

With the right argument, `ggplot` automatically shades the intersecting region with a different color. We will show examples of **ggplot2** code for densities in Section 10 as well as Section 9.16.

### 9.7 Exercises

1. In the `murders` dataset, the region is a categorical variable and the following is its distribution:

![](https://rafalab.github.io/dsbook/book_files/figure-html/barplot-exercise-1.png)

To the closest 5%, what proportion of the states are in the North Central region?

> 0.25%

2. Which of the following is true:

> B.

A.  The graph above is a histogram.

B.  The graph above shows only four numbers with a bar plot.

C.  Categories are not numbers, so it does not make sense to graph the distribution.

D.  The colors, not the height of the bars, describe the distribution.

3. The plot below shows the eCDF for male heights:

![](https://rafalab.github.io/dsbook/book_files/figure-html/ecdf-exercise-1.png)

Based on the plot, what percentage of males are shorter than 75 inches?

> B.

A.  100%

B.  95%

C.  80%

D.  72 inches

4. To the closest inch, what height `m` has the property that 1/2 of the male students are taller than `m` and 1/2 are shorter?

> C.

A.  61 inches

B.  64 inches

C.  69 inches

D.  74 inches

5. Here is an eCDF of the murder rates across states:

![](https://rafalab.github.io/dsbook/book_files/figure-html/ecdf-exercise-2-1.png)

Knowing that there are 51 states (counting DC) and based on this plot, how many states have murder rates larger than 10 per 100,000 people?

> A.

> 약 99%의 값들이 a = 10 아래에 있기 때문

A. 1

B. 5

C. 10

D. 50

6. Based on the eCDF above, which of the following statements are true:

> D.

A.  About half the states have murder rates above 7 per 100,000 and the other half below.

B.  Most states have murder rates below 2 per 100,000.

C.  All the states have murder rates above 2 per 100,000.

D.  With the exception of 4 states, the murder rates are below 5 per 100,000.

7. Below is a histogram of male heights in our `heights` dataset:

![](https://rafalab.github.io/dsbook/book_files/figure-html/height-histogram-exercise-1.png)

Based on this plot, how many males are between 63.5 and 65.5?

> A.

A.  10

B.  24

C.  34

D.  100

8. About what **percentage** are shorter than 60 inches?

> A.

A.  1%

B.  10%

C.  25%

D.  50%

9. Based on the density plot below, about what proportion of US states have populations larger than 10 million?

![](https://rafalab.github.io/dsbook/book_files/figure-html/density-exercise-1.png)

> B.

A.  0.02

B.  0.15

C.  0.50

D.  0.55

10. Below are three density plots. Is it possible that they are from the same dataset?

![](https://rafalab.github.io/dsbook/book_files/figure-html/density-exercise-2-1.png)

Which of the following statements is true:

> A.

> 2&3 dataset은 같은 dataset이고, smooth의 차이인 것 같은데, 1 dataset은 다른 dataset으로 보임

A.  It is impossible that they are from the same dataset.

B.  They are from the same dataset, but the plots are different due to code errors.

C.  They are the same dataset, but the first and second plot undersmooth and the third oversmooths.

D.  They are the same dataset, but the first is not in the log scale, the second undersmooths and the third oversmooths.

### 9.8 The normal distribution

Histograms and density plots provide excellent summaries of a distribution. But we often see the average and standard deviation used as summary statistics: a two-number summary. To understand what these summaries are and why they are so widely used, we need to understand the normal distribution.

The normal distribution, also known as the bell curve and as the Gaussian distribution, is one of the most famous mathematical concepts in history. A reason for this is that approximately normal distributions occur in many situations.  
Here we focus on how the normal distribution helps us summarize data.

Rather than using data, the normal distribution is defined with a mathematical formula. For any interval $(a, b)$, the proportion of values in that interval can be computed using this formula:

<center>$Pr(a < x < b) = \int_{a}^{b}\frac{1}{\sqrt{2π}s}e^{-\tfrac{1}{2}(\tfrac{x-m}{s})^2}$</center>

it is completely defined by just two parameters: $m$ and $s$. These two parameters, $m$ and $s$, are referred to as the _average_ (also called the _mean_) and the _standard deviation_ (SD) of the distribution respectively.

The distribution is symmetric, centered at the average, and most values (about 95%) are within 2 SDs from the average.

the normal distribution looks like when the average is 0 and the SD is 1:

![](https://rafalab.github.io/dsbook/book_files/figure-html/normal-distribution-density-1.png)

The distribution is defined by just two parameters implies that if a dataset is approximated by a normal distribution, all the information needed to describe the distribution can be encoded in just two numbers: the average and the standard deviation.

For a list of numbers contained in a vector x, the average is defined as:

```{r}
m <- sum(x) / length(x)
```

and th SD is defined as:

```{r}
s <- sqrt(sum((x-mu)^2) / length(x))
```

which can be interpreted as the average distance between values and their average.

Let’s compute the values for the height for males which we will store in the object $x$:

```{r}
index <- heights$sex == "Male"
x <- heights$height[index]
```

The pre-built functions `mean` and `sd` (`sd` divides by `length(x)-1` rather than `length(x)`) can be used here:

```{r}
m <- mean(x)
s <- sd(x)
c(average = m, sd = s)
```

A plot of the smooth density and the normal distribution with mean = 69.3 and SD = 3.6 plotted as a black line with our student height smooth density in blue:

![](https://rafalab.github.io/dsbook/book_files/figure-html/data-and-normal-densities-1.png)

The normal distribution does appear to be quite a good approximation here.

### 9.9 Standard units

The _standard unit_ of a value tells us how many standard deviations away from the average it is. Specifically, for a value `x` from a vector `X`, we define the value of `x` in standard units as `z = (x - m)/s` with `m` and `s` the average and standard deviation of `X` respectively.

We can obtain standard units using the function `scale`:

```{r}
z <- scale(x)
```

Now to see how many men are within 2 SDs from the average, we simply type:

```{r}
mean(abs(z) < 2)
```

The proportion is about 95%, which is what the normal distribution predicts.  
The approximation is a good one, we can use quantile-quantile plots.

### 9.10 Quantile-quantile plots

A systematic way to assess how well the normal distribution fits the data is to check if the observed and predicted proportions match. In general, this is the approach of the quantile-quantile plot (QQ-plot).

First let’s define the theoretical quantiles for the normal distribution. In statistics books we use the symbol $\Phi(x)$ to define the function that gives us the probability of a standard normal distribution being smaller than $x$.

For example, $\Phi(-1.96) = 0.025$ and $\Phi(1.96) = 0.975$. In R, we can evaluate $\Phi$ using the `pnorm` function:

```{r}
pnorm(-1.96)
```

The inverse function $\Phi^{-1}(x)$ gives us the _theoretical quantiles_ for the normal distribution.

For example, $\Phi^{-1}(0.975) = 1.96$. In R, we can evaluate the inverse of $\Phi$ using the `qnorm` function.

```{r}
qnorm(0.975)
```

These calculations are for the standard normal distribution by default (mean = 0, standard deviation = 1), but we can also define these for any normal distribution. We can do this using the `mean` and `sd` arguments in the `pnorm` and `qnorm` function.

We can use `qnorm` to determine quantiles of a distribution with a specific average and standard deviation

```{r}
qnorm(0.975, mean = 5, sd = 2)
```

For the normal distribution, all the calculations related to quantiles are done without data, thus the name _theoretical quantiles_. But quantiles can be defined for any distribution, including an empirical one.

So if we have data in a vector $x$, we can define the quantile associated with any proportion $p$ as the $q$ for which the proportion of values below $q$ is $p$.  
Using R code, we can define `q` as the value for which `mean(x <= q) = p`.

For the male heights data, we have that:

```{r}
mean(x <= 69.5)
```

So about 50% are shorter or equal to 69 inches. This implies that if $p = 0.50$ then $q = 69.5$.

The idea of a QQ-plot is that if your data is well approximated by normal distribution then the quantiles of your data should be similar to the quantiles of a normal distribution.

Let’s construct a QQ-plot using R code. Start by defining the vector of proportions.

```{r}
p <- seq(0.05, 0.95, 0.05)
```

To obtain the quantiles from the data, we can use the `quantile` function like this:

```{r}
sample_quantiles <- quantile(x, p)
```

To obtain the theoretical normal distribution quantiles with the corresponding average and SD, we use the `qnorm` function:

```{r}
theoretical_quantiles <- qnorm(p, mean = mean(x), sd = sd(x))
```

To see if they match or not, we plot them against each other and draw the identity line:

```{r}
qplot(theoretical_quantiles, sample_quantiles) + geom_abline()
```

This code becomes much cleaner if we use standard units:

```{r}
sample_quantiles <- quantile(z, p)
theoretical_quantiles <- qnorm(p)
qplot(theoretical_quantiles, sample_quantiles) + geom_abline()
```

The above code is included to help describe QQ-plots. However, in practice it is easier to use the **ggplot2** code described in Section 9.16:

```{r}
heights %>% filter(sex == "Male") %>%
  ggplot(aes(sample = scale(height))) +
  geom_qq() +
  geom_abline()
```

While for the illustration above we used 20 quantiles, the default from the `geom_qq` function is to use as many quantiles as data points.

### 9.11 Percentiles

_Percentiles_ are special cases of _quantiles_ that are commonly used.  
The percentiles are the quantiles you obtain when setting the $p$ at $0.01, 0.02,..., 0.99$.

Special case that receives a name are the _quartiles_, which are obtained when setting $p = 0.25, 0.50$, and $0.75$.

### 9.12 Boxplots

Suppose we want to summarize the murder rate distribution.

![](https://rafalab.github.io/dsbook/book_files/figure-html/hist-qqplot-non-normal-data-1.png)

Suppose those used to receiving just two numbers as summaries ask us for a more compact numerical summary.

Tukey offered some advice. Provide a five-number summary composed of the range along with the quartiles (the 25th, 50th, and 75th percentiles). Tukey further suggested that we ignore _outliers_ when computing the range and instead plot these as independent points.  
Finally, he suggested we plot these numbers as a “box” with “whiskers” like this:

![](https://rafalab.github.io/dsbook/book_files/figure-html/first-boxplot-1.png)

> with the box defined by the 25% and 75% percentile and the whiskers showing the range.  
> The distance between these two is called the _interquartile range_.  
> The two points are outliers according to Tukey’s definition.  
> The median is shown with a horizontal line.

We know that the median is about 2.5, that the distribution is not symmetric, and that the range is 0 to 5 for the great majority of states with two exceptions.

### 9.13 Stratification

In data analysis we often divide observations into groups based on the values of one or more variables associated with those observations.  
We call this procedure _stratification_ and refer to the resulting groups as _strata_.

We are often interested in how the distribution of variables differ across different subgroups.

### 9.14 Case study: describing student heights (continued)

We learned that boxplots are useful when we want to quickly compare two or more distributions.

The heights for men and women:

![](https://rafalab.github.io/dsbook/book_files/figure-html/female-male-boxplots-1.png)

The plot immediately reveals that males are, on average, taller than females. The standard deviations appear to be similar.

We expect that they will follow a normal distribution, just like males. However, exploratory plots reveal that the approximation is not as useful:

![](https://rafalab.github.io/dsbook/book_files/figure-html/histogram-qqplot-female-heights-1.png)

> The density plot has a second “bump”.  
> The QQ-plot shows that the highest points tend to be taller than expected by the normal distribution.  
> Also see five points in the QQ-plot that suggest shorter than expected heights for a normal distribution.

Explanation is that in the form students used to enter their heights, `FEMALE` was the default sex and some males entered their heights, but forgot to change the sex variable.

Regarding the five smallest values, note that these values are:

```{r}
heights %>% filter(sex == "Female") %>%
  top_n(5, desc(height)) %>% pull(height)
```

Because these are reported heights, a possibility is that the student meant to enter 5’1“, 5’2”, 5’3" or 5’5“.

### 9.15 Exercises

1. Define variables containing the heights of males and females like this:

```{r}
library(dslabs)
data(heights)
male <- heights$height[heights$sex == "Male"]
female <- heights$height[heights$sex == "Female"]
```

How many measurements do we have for each?

```{r}
length(male)
length(female)
```

2. Suppose we can’t make a plot and want to compare the distributions side by side. We can’t just list all the numbers. Instead, we will look at the percentiles. Create a five row table showing `female_percentiles` and `male_percentiles` with the 10th, 30th, 50th, …, 90th percentiles for each sex. Then create a data frame with these two as columns.

```{r}
female_percentiles <- data.frame(quantile(female, c(0.1, 0.3, 0.5, 0.7, 0.9)))
female_percentiles
male_percentiles <- data.frame(quantile(male, c(0.1, 0.3, 0.5, 0.7, 0.9)))
male_percentiles
```

3. Study the following boxplots showing population sizes by country:

![](https://rafalab.github.io/dsbook/book_files/figure-html/boxplot-exercise-1.png)

Which continent has the country with the biggest population size?

> Asia

4. What continent has the largest median population size?

> Africa

5. What is median population size for Africa to the nearest million?

> 10

6. What proportion of countries in Europe have populations below 14 million?

> A.

A.  0.99

B.  0.75

C.  0.50

D.  0.25

7. If we use a log transformation, which continent shown above has the largest interquartile range?

> Asia

8. Load the height data set and create a vector x with just the male heights:

```{r}
library(dslabs)
data(heights)
x <- heights$height[heights$sex == "Male"]
```

What proportion of the data is between 69 and 72 inches (taller than 69, but shorter or equal to 72)? Hint: use a logical operator and mean.

```{r}
mean(x > 69 & x <= 72)
```

9. Suppose all you know about the data is the average and the standard deviation. Use the normal approximation to estimate the proportion you just calculated. Hint: start by computing the average and standard deviation. Then use the pnorm function to predict the proportions.

```{r}
m <- mean(x)
s <- sd(x)
c(average = m, sd = s)
pnorm(72, m, s) - pnorm(69, m, s)
```

10. Notice that the approximation calculated in question two is very close to the exact calculation in the first question. Now perform the same task for more extreme values. Compare the exact calculation and the normal approximation for the interval (79,81]. How many times bigger is the actual proportion than the approximation?

```{r}
mean(x > 79 & x <= 81)
pnorm(81, mean(x), sd(x)) - pnorm(79, mean(x), sd(x))

mean(x > 79 & x <= 81) / (pnorm(81, mean(x), sd(x)) - pnorm(79, mean(x), sd(x)))
```

11. Approximate the distribution of adult men in the world as normally distributed with an average of 69 inches and a standard deviation of 3 inches. Using this approximation, estimate the proportion of adult men that are 7 feet tall or taller, referred to as _seven footers_. Hint: use the pnorm function.

```{r}
seven_footers <- 1-pnorm(7*12, mean = 69, sd = 3)
seven_footers
```

12. There are about 1 billion men between the ages of 18 and 40 in the world. Use your answer to the previous question to estimate how many of these men (18-40 year olds) are seven feet tall or taller in the world?

```{r}
1-pnorm(7*12, mean = 69, sd = 3)
```

13. There are about 10 National Basketball Association (NBA) players that are 7 feet tall or higher. Using the answer to the previous two questions, what proportion of the world’s 18 to 40 year old seven footers are in the NBA?

```{r}
1-pnorm(7*12, mean = 69, sd = 3)
```

14. Repeat the calculations performed in the previous question for Lebron James’ height: 6 feet 8 inches. There are about 150 players that are at least that tall.

```{r}
1-pnorm(6*12+8, mean = 69, sd = 3)
```

15. In answering the previous questions, we found that it is not at all rare for a seven footer to become an NBA player. What would be a fair critique of our calculations:

> C.

> 80인치 이상인 사람은 약 0.0001%이고, NBA에서 150명임  
> 84인치 이상인 사람은 약 0.0000003%이고, NBA에서 10명임  
> 150명 중 10명은 약 0.07%임  
> 따라서 underestimate되었다고 생각함

A.  Practice and talent are what make a great basketball player, not height.

B.  The normal approximation is not appropriate for heights.

C.  As seen in question 3, the normal approximation tends to underestimate the extreme values. It’s possible that there are more seven footers than we predicted.

D.  As seen in question 3, the normal approximation tends to overestimate the extreme values. It’s possible that there are less seven footers than we predicted.

### 9.16 ggplot2 geometries

Demonstrate how to generate plots related to distributions, specifically the plots shown earlier in this chapter.

#### 9.16.1 Barplots

To generate a barplot we can use the `geom_bar` geometry. The default is to count the number of each category and draw a bar.

The plot for the regions of the US.

```{r}
murders %>% ggplot(aes(region)) + geom_bar()
```

We often already have a table with a distribution that we want to present as barplot. 
An example such a table:

```{r}
data(murders)
tab <- murders %>%
  count(region) %>%
  mutate(proportion = n/sum(n))
tab
```

We no longer want `geom_bar` to count, but rather just plot a bar to the height provided by the `proportion` variable. For this we need to provide `x` (the categories) and `y` (the values) and use the `stat="identity"` option.

```{r}
tab %>% ggplot(aes(region, proportion)) + geom_bar(stat = "identity")
```

#### 9.16.2 Histograms

To generate histograms we use `geom_histogram`. By looking at the help file for this function, we learn that the only required argument is `x`, the variable for which we will construct a histogram.

We dropped the `x` because we know it is the first argument. The code looks like this:

```{r}
heights %>%
  filter(sex == "Female") %>%
  ggplot(aes(height)) +
  geom_histogram()
```

If we run the code above, it gives us a message:

> `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.

We previously used a bin size of 1 inch, so the code looks like this:

```{r}
heights %>%
  filter(sex == "Female") %>%
  ggplot(aes(height)) +
  geom_histogram(binwidth = 1)
```

Finally, if for aesthetic reasons we want to add color, we use the arguments described in the help file. We also add labels and a title:

```{r}
heights %>%
  filter(sex == "Female") %>%
  ggplot(aes(height)) +
  geom_histogram(binwidth = 1, fill = "blue", col = "black") +
  xlab("Male heights in inches") +
  ggtitle("Histogram")
```

#### 9.16.3 Density plots

To create a smooth density, we use the `geom_density`.

Data previously shown as a histogram:

```{r}
heights %>%
  filter(sex == "Female") %>%
  ggplot(aes(height)) +
  geom_density()
```

To fill in with color, we can use the fill argument.

```{r}
heights %>%
  filter(sex == "Female") %>%
  ggplot(aes(height)) +
  geom_density(fill = "blue")
```

To change the smoothness of the density, we use the `adjust` argument to multiply the default value by that `adjust`. For example, if we want the bandwidth to be twice as big we use:

```{r}
heights %>%
  filter(sex == "Female") %>%
  ggplot(aes(height)) +
  geom_density(fill = "blue", adjust = 2)
```

#### 9.16.4 Boxplots

The geometry for boxplot is geom_boxplot. As discussed, boxplots are useful for comparing distributions.

We need arguments `x` as the categories, and `y` as the values.

#### 9.16.5 QQ-plots

For qq-plots we use the geom_qq geometry.  
From the help file, we learn that we need to specify the `sample`.

The qqplot for men heights.

```{r}
heights %>%
  filter(sex == "Male") %>%
  ggplot(aes(sample = height)) +
  geom_qq()
```

By default, the sample variable is compared to a normal distribution with average 0 and standard deviation 1.  
To change this, we use the `dparams` arguments based on the help file.

Adding an identity line is as simple as assigning another layer. For straight lines, we use the `geom_abline` function. The default line is the identity line (slope = 1, intercept = 0).

```{r}
params <- heights %>%
  filter(sex == "Male") %>%
  summarize(mean = mean(height), sd = sd(height))

heights %>% filter(sex == "Male") %>%
  ggplot(aes(sample = height)) +
  geom_qq(dparams = params) +
  geom_abline()
```

Another option here is to scale the data first and then make a qqplot against the standard normal.

```{r}
heights %>%
  filter(sex == "Male") %>%
  ggplot(aes(sample = scale(height))) +
  geom_qq() +
  geom_abline()
```

#### 9.16.6 Images

We introduce the two geometries used to create images: **geom_tile** and **geom_raster**. They behave similarly.

To create an image in **ggplot2** we need a data frame with the x and y coordinates as well as the values associated with each of these. Here is an a data frame.

```{r}
x <- expand.grid(x = 1:12, y = 1:10) %>%
  mutate(z = 1:120)
```

This is the tidy version of a matrix, `matrix(1:120, 12, 10)`. To plot the image we use the following code:

```{r}
x %>% ggplot(aes(x, y, fill = z)) +
  geom_raster()
```

With these images you will often want to change the color scale. This can be done through the `scale_fill_gradientn` layer.

```{r}
x %>% ggplot(aes(x, y, fill = z)) +
  geom_raster() +
  scale_fill_gradientn(colors = terrain.colors(10))
```

#### 9.16.7 Quick plots

We can also use `qplot` to make histograms, density plots, boxplot, qqplots and more. Although it does not provide the level of control as `ggplot`, `qplot` is definitely useful as it permits us to make a plot with a short snippet of code.

Suppose we have the female heights in an object `x`:

```{r}
x <- heights %>%
  filter(sex == "Male") %>%
  pull(height)
```

To make a quick histogram we can use:

```{r}
qplot(x)
```

The function guesses that we want to make a histogram because we only supplied one variable.  
If we supply `qplot` two variables, it automatically makes a scatterplot.

To make a quick qqplot you have to use the `sample` argument.  
Note that we can add layers just as we do with `ggplot`.

```{r}
qplot(sample = scale(x)) + geom_abline()
```

If we supply a factor and a numeric vector, we obtain a plot like the below.  
In the code below we are using the `data` argument. Because the data frame is not the first argument in `qplot`, we have to use the dot operator.

```{r}
heights %>% qplot(sex, height, data = .)
```

We can also select a specific geometry by using the `geom` argument.

So to convert the plot above to a boxplot, we use the following code:

```{r}
heights %>% qplot(sex, height, dat = ., geom = "boxplot")
```

We can also use the `geom` argument to generate a density plot instead of a histogram:

```{r}
qplot(x, geom = "density")
```

Although not as much as with `ggplot`, we do have some flexibility to improve the results of `qplot`. Looking at the help file we see several ways in which we can improve the look of the histogram above.

```{r}
qplot(x, bins = 15, color = I("black"), xlab = "Population")
```

**Technical note**: The reason we use `I("black")` is because we want `qplot` to treat `"black"` as a character rather than convert it to a factor, which is the default behavior within `aes`, which is internally called here.  
In general, the function `I` is used in R to say “keep it as it is”.

### 9.17 Exercises

1. Now we are going to use the `geom_histogram` function to make a histogram of the heights in the `height` data frame. When reading the documentation for this function we see that it requires just one mapping, the values to be used for the histogram. Make a histogram of all the plots.

What is the variable containing the heights?

> C.

A.  `sex`

B.  `heights`

C.  `height`

D.  `heights$height`

2. Now create a ggplot object using the pipe to assign the heights data to a ggplot object. Assign `height` to the x values through the `aes` function.

```{r}
heights %>% ggplot(aes(height))
```

3. Now we are ready to add a layer to actually make the histogram. Use the object created in the previous exercise and the `geom_histogram` function to make the histogram.

```{r}
heights %>%
  ggplot(aes(height)) +
  geom_histogram()
```

4. Note that when we run the code in the previous exercise we get the warning: `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.

Use the `binwidth` argument to change the histogram made in the previous exercise to use bins of size 1 inch.

```{r}
heights %>%
  ggplot(aes(height)) +
  geom_histogram(binwidth = 1)
```

5. Instead of a histogram, we are going to make a smooth density plot. In this case we will not make an object, but instead render the plot with one line of code. Change the geometry in the code previously used to make a smooth density instead of a histogram.

```{r}
heights %>%
  ggplot(aes(height)) +
  geom_density()
```

6. Now we are going to make a density plot for males and females separately. We can do this using the `group` argument. We assign groups via the aesthetic mapping as each point needs to a group before making the calculations needed to estimate a density.

```{r}
heights %>%
  ggplot(aes(height, group = sex)) +
  geom_density()
```

7. We can also assign groups through the `color` argument. This has the added benefit that it uses color to distinguish the groups. Change the code above to use color

```{r}
heights %>%
  ggplot(aes(height, color = sex)) +
  geom_density()
```

8. We can also assign groups through the `fill` argument. This has the added benefit that it uses colors to distinguish the groups, like this:

```{r}
heights %>%
  ggplot(aes(height, fill = sex)) +
  geom_density()
```

However, here the second density is drawn over the other. We can make the curves more visible by using alpha blending to add transparency. Set the alpha parameter to 0.2 in the `geom_density` function to make this change.

```{r}
heights %>%
  ggplot(aes(height, fill = sex)) +
  geom_density(alpha = 0.2)
```

```{r}
heights %>%
  ggplot(aes(height, fill = sex)) +
  geom_density(aes(alpha = 0.2))
```

> `aes`에 넣으면 색이 더 진해진다!
